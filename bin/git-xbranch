#!/bin/sh
# vim: set ts=8 sts=3 sw=3 et ai:

commitcountstr() {
   read count
   if test "$count" -eq 1; then
      printf "1 commit"
   else
      printf "%d commits" "$count"
   fi
}

headsha1=$(git rev-parse HEAD) ||
   { echo "HEAD must be valid to use xbranch"; exit 1; }
if git config --get-colorbool color.xbranch; then
   colcurbranch="$(git config --get-color color.xbranch.current "green")"
   colahead="$(git config --get-color color.xbranch.ahead "yellow bold")"
   colbehind="$(git config --get-color color.xbranch.behind "yellow bold")"
   coluptodate="$(git config --get-color color.xbranch.uptodate "green bold")"
   coldiverged="$(git config --get-color color.xbranch.diverged "red bold")"
   colreset="$(git config --get-color "" "reset")"
else
   colcurbranch=""
   colahead=""
   colbehind=""
   coluptodate=""
   coldiverged=""
   colreset=""
fi

print_branch() {
   local sha1="$1"
   local objtype="$2"
   local branch="$3"

   # is this branch the current branch?
   local marker; local uibranch;
   if test "$sha1" = "$headsha1"; then
      marker="*"
      uibranch="$colcurbranch$branch$colreset"
   else
      marker=" "
      uibranch="$branch"
   fi

   # find remote tracking info for the branch
   local info=""
   local istracking=true
   local remote=$(git config --get branch."$branch".remote) || istracking=false
   local merge=$(git config --get branch."$branch".merge) || istracking=false
   if test z"$remote" = z || test z"$merge" = z ; then
      istracking=false
   fi
   local remoteref
   $istracking && {
      remoteref="$remote"/"${merge#refs/heads/}"
      $istracking && {
         remotesha1=$(git rev-parse refs/remotes/"$remoteref" 2> /dev/null) ||
            { istracking=false; info=" [tracking broken: 'refs/remotes/$remoteref' doesn't exist]" ; }
      }
      $istracking && {
         basesha1=$(git merge-base "$sha1" "$remotesha1" 2> /dev/null) ||
            { istracking=false; info=" [full divergence: no merge base found]" ; }
      }
   }

   $istracking && {
      if test "$basesha1" = "$sha1" && test "$basesha1" = "$remotesha1"; then
         # HEAD is up-to-date
         info=" [${coluptodate}up-to-date${colreset} with '${remoteref}']"
      elif test "$basesha1" = "$sha1"; then
         # HEAD is behind upstream
         local count="$(git rev-list --count "$sha1".."$remotesha1" | commitcountstr)"
         info=" [${colbehind}behind${colreset} '${remoteref}' by ${count}]"
      elif test "$basesha1" = "$remotesha1"; then
         # upstream is behind HEAD
         local count="$(git rev-list --count "$basesha1".."$sha1" | commitcountstr)"
         info=" [${colahead}ahead${colreset} of '${remoteref}' by ${count}]"
      else
         # upstream and HEAD have diverged
         local counthead="$(git rev-list --count "$basesha1".."$sha1" | commitcountstr)"
         local countremote="$(git rev-list --count "$basesha1".."$remotesha1" | commitcountstr)"
         info=" [${coldiverged}diverged${colreset} from '${remoteref}', by ${counthead}/${countremote} (us/them)]"
      fi
   }

   printf "%s %s%s\n" "$marker" "$uibranch" "$info"

   return 0
}

# this is filled in by git for-each-ref and then evaluated
fmt='print_branch %(objectname) %(objecttype) %(refname:short)'
eval "$(git for-each-ref --shell --format="$fmt" refs/heads)"
